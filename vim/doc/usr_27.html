<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=gb2312">
<title>VIM: usr_27</title>
<link rel="stylesheet" href="vim-stylesheet.css" type="text/css">
</head>
<body>
<h2>USR_27</h2>
<pre>
<b class="vimtag">*<a name="usr_27.txt">usr_27.txt</a>*</b>    For Vim version 6.2.            最后修改: 2002年8月31日

                     VIM 用户手册 - Bram Moolenaar 著
                  (译者： Chimin Yen http://vimcdoc.sf.net )

                             查找命令及模式


在第三章里，我们曾经提到过几个简单的查找模式 |<a href="usr_03.html#03.9">03.9</a>|。Vim 能够胜任复杂得多的查
找。本章将解释那些最常用到的模式。详细的说明可以查阅: |<a href="pattern.html#pattern">pattern</a>|

|<a href="usr_27.html#27.1">27.1</a>|  忽略大小写
|<a href="usr_27.html#27.2">27.2</a>|  在文件尾折返
|<a href="usr_27.html#27.3">27.3</a>|  偏移
|<a href="usr_27.html#27.4">27.4</a>|  匹配重复性模式
|<a href="usr_27.html#27.5">27.5</a>|  多择一
|<a href="usr_27.html#27.6">27.6</a>|  字符域
|<a href="usr_27.html#27.7">27.7</a>|  字符类
|<a href="usr_27.html#27.8">27.8</a>|  匹配换行符
|<a href="usr_27.html#27.9">27.9</a>|  举例

       下一章: |<a href="usr_28.html#usr_28.txt">usr_28.txt</a>|  折叠
       前一章: |<a href="usr_26.html#usr_26.txt">usr_26.txt</a>|  重复
         目录: |<a href="usr_toc.html#usr_toc.txt">usr_toc.txt</a>|

</pre><hr><pre><b class="vimtag">*<a name="27.1">27.1</a>*</b>  忽略大小写

默认情况下，Vim 的查找是大小写敏感的。因此，"include"，"INCLUDE"，和 "Include"
为三个各不相同的词，而一次查找将仅仅匹配其中的一个。
   现在设定 'ignorecase' 选项:
<code class="example"></code>
<code class="example">        :set ignorecase</code>
<code class="example"></code>
再查找 "include"，现在它将匹配 "Include"，"INCLUDE" 和 "InClUDe"。(设定
'hlsearch' 选项可以快速查看哪儿有模式的匹配。)
   你可以这样撤销这个选项:
<code class="example"></code>
<code class="example">        :set noignorecase</code>
<code class="example"></code>
但是我们且保留这个设定，并查找 "INCLUDE"。它匹配的文本就跟查找 "include" 时
一模一样。现在我们设定 'smartcase' 选项:
<code class="example"></code>
<code class="example">        :set ignorecase smartcase</code>
<code class="example"></code>
如果你采用的模式里至少有一个大写字母，查找就成了大小写敏感的。可以这样理解，你
不必键入大写字母，也能查找到含有大写字母的词，所以，你若键入大写字母，必然是因
为你要大小写敏感的匹配。聪明!
    设定了这两个选项，你会找到以下匹配:

<code class="section">        模式                    匹配    </code>
        word                    word，Word，WORD，WoRd，等。
        Word                    Word
        WORD                    WORD
        WoRd                    WoRd


单 个 模 式 里 的 大 小 写

如果你仅想忽略一个特定的模式里的大小写，那么，在模式前添加 "\c" 字符串就行了。
添加 "\C" 将使该模式的匹配大小写敏感。这排除了 'ignorecase' 和 'smartcase'
选项的影响，当 "\c" 或 "\C" 起作用时，它们设成什么值无关紧要。

<code class="section">        模式                    匹配    </code>
        \Cword                  word
        \CWord                  Word
        \cword                  word，Word，WORD，WoRd，等。
        \cWord                  word，Word，WORD，WoRd，等。

采用 "\c" 和 "\C"
的好处在于它粘附在所用的模式上。因此，重复查找历史记录里的某个模式会产生同样
的结果。'ignorecase' 或 'smartcase' 是否更改部影响结果。

        <code class="note">Note:</code>
        在查找模式中使用以 "\" 开头的项，其效果取决于 'magic' 选项。在本章中,
        我们将假定 'magic' 为真。这也是标准和建议的设定。如果你把它改了,
        那么，许多查找模式就会突然变得无效了。

        <code class="note">Note:</code>
        如果你查了好久，超过了你预计的时间，你可以中断查找，在 Unix 上用
        <code class="keystroke">CTRL-C</code>，而在 MS-DOS 和微软视窗上则用 <code class="keystroke">CTRL-Break</code>。

</pre><hr><pre><b class="vimtag">*<a name="27.2">27.2</a>*</b>  在文件尾折返

在默认情况下，正向查找从当前光标位置开始，查找特定的字符串。然后它就遇到了文
件尾。如果那个时候还没找到那个字符串，它就从头来过，从文件开头一直查到光标处。
   记住，当你不断以 "n" 命令查找下一个匹配时，你最终回到第一个匹配。如果你不
注意，你将永远找下去! 为了提醒你，Vim 显示如下信息:

<code class="section">        search hit BOTTOM，continuing at TOP </code>

如果你使用 "?" 命令按相反方向查找，你得到的信息是这样的:

<code class="section">        search hit TOP，continuing at BOTTOM </code>

可是，你还是不知道你何时回到了第一个匹配。一种办法是设定 'ruler' 选项:
<code class="example"></code>
<code class="example">        :set ruler</code>
<code class="example"></code>
Vim 将把光标位置显示在窗口的右下角 (如果使用了状态条的话，会显示在那里)。看起
来像这样:

<code class="section">        101,29       84% </code>

第一个数字是光标所在的行号。在你开始查找的时候记住行号，那样你就能检查是否越
过了该位置。


无 折 返 查 找

要取消查找折返功能，请用以下命令:
<code class="example"></code>
<code class="example">        :set nowrapscan</code>
<code class="example"></code>
现在当查找遇到文件末尾，一个出错信息就会显示出来:

<code class="section">        E385: search hit BOTTOM without match for: forever </code>

这样，你只要用 "gg" 命令回到文件开头，并一直查到你看到以上信息，你就能找到所
有的匹配。
   如果你用 "?" 从相反方向查找，你将得到:

<code class="section">        E384: search hit TOP without match for: forever </code>

</pre><hr><pre><b class="vimtag">*<a name="27.3">27.3</a>*</b>  偏移

在默认情况下，查找命令让光标停留在匹配的模式的开始。你可以指定一个偏移，告诉
Vim 将光标停留在别的位置上。在正向查找命令 "/" 中指定偏移，就是在模式后面附加
一个斜线符 (/) 以及偏移值:
<code class="example"></code>
<code class="example">        /默认/2</code>
<code class="example"></code>
这个命令查找模式 "默认"。找到后使光标越过匹配的模式而前移两行，并停留在该行的
行首。把这个命令用于以上段落中，Vim 在第一行找到词 "默认"。接着光标再往下移两行，
落在 "一个" 的 "一" 上。

如果该偏移为一简单数字，那么光标就会被放置在距离匹配那么多行的那一行的行首。
该偏移值可为正数或负数。如果它是正数，光标会向前移该数表示的行; 若为负数，则往
回退该数表示的行。


字 符 偏 移

偏移符 "e" 表示一个偏移从匹配末尾算起。它把光标移到匹配的最后一个字符上。命令:
<code class="example"></code>
<code class="example">        /const/e</code>
<code class="example"></code>
把光标放到单词 "const" 的 "t" 上。
   加一个数字，光标就从该位置再前移该数字指定的那么多个字符。下面这个命令会将
光标移到匹配后面第一个字符:
<code class="example"></code>
<code class="example">        /const/e+1</code>
<code class="example"></code>
一个正数使光标右移，负数使其左移。例如:
<code class="example"></code>
<code class="example">        /const/e-1</code>
<code class="example"></code>
会把光标移到单词 "const" 的 "s" 字符上。

如果偏移以 "b" 开头，那么光标就移到匹配模式的首位。因为不用 "b" 光标也一样会被
移到首位，所以单独使用时没什么意义。在将它与一个加上或减去的数字合起来时，就很
有用了。光标就会前移或后移那么多个字符。例如:
<code class="example"></code>
<code class="example">        /const/b+2</code>
<code class="example"></code>
会把光标移到匹配的首位，再往右移两个字符。因而落在字符 "n" 上。


重 复

当你重复前一次使用过的查找模式，只是偏移不同时，你可以把模式省略了:
<code class="example"></code>
<code class="example">        /that</code>
<code class="example">        //e</code>
<code class="example"></code>
等于:
<code class="example"></code>
<code class="example">        /that/e</code>
<code class="example"></code>
再以同样的偏移重复查找:
<code class="example"></code>
<code class="example">        /</code>
<code class="example"></code>
命令 "n" 具有同样的作用。要取消一个以前用过的偏移可以用:
<code class="example"></code>
<code class="example">        //</code>
<code class="example"></code>
<code class="example"></code>
反 向 查 找

命令 "?" 以相同的方式使用偏移，但你必须以 "?" 来分隔模式和偏移，而非 "/":
<code class="example"></code>
<code class="example">        ?const?e-2</code>
<code class="example"></code>
偏移符 "b" 和 "e" 的用途是一样的。它们并不因为使用了 "?" 而改变方向。


起 始 位 置

查找时，通常从光标位置开始。当你规定的是一个行偏移，这可能造成麻烦。例如:
<code class="example"></code>
<code class="example">        /const/-2</code>
<code class="example"></code>
这个命令找到下一个单词 "const"，然后上移两行。如果你用命令 "n" 再找，Vim 就
从当前位置开始，找到同一个 "const" 匹配。然后再一次在偏移的作用下，回到开始
的地方。你给套住了!
   还有比这更糟糕的: 假定下一行另有一个 "const" 匹配。那么，重复正向查找就会
找到这个匹配，并上移两行。这样你实际上把光标往回移了!

当你规定的是一个字符偏移，Vim 将为其作调整。因此，查找会向前或向后跳过几个字
符再开始，以便同一个匹配不至于再出现。

</pre><hr><pre><b class="vimtag">*<a name="27.4">27.4</a>*</b>  匹配重复性模式

星号项 "*" 规定在它前面的项可以重复任意次。因此:
<code class="example"></code>
<code class="example">        /a*</code>
<code class="example"></code>
匹配 "a"，"aa"，"aaa"，等等。但也匹配 "" (空字串)，因为零次也包含在内。
   星号 "<b class="vimtag">*<a name="%22 仅仅应用于那个紧邻在它前面的项。因此 %22ab">" 仅仅应用于那个紧邻在它前面的项。因此 "ab</a>*</b>" 匹配 "a"，"ab"，"abb",
"abbb"，等等。如要多次重复整个字符串，那么该字符串必须被组成一个项。组成一项的
方法就是在它前面加 "\("，后面加 "\)"。因此这个命令:
<code class="example"></code>
<code class="example">        /\(ab\)*</code>
<code class="example"></code>
匹配: "ab"，"abab"，"ababab"，等等。而且也匹配 ""。

要避免匹配空字串，使用 "\+"。这表示前面一项可以被匹配一次或多次。

<code class="example">        /ab\+</code>
<code class="example"></code>
匹配 "ab"，"abb"，"abbb"，等等。它不匹配 后面没有跟随 "b" 的 "a"。

要匹配一个可选项，用 "\="。 例如:
<code class="example"></code>
<code class="example">        /folders\=</code>
<code class="example"></code>
匹配 "folder" 和 "folders"。


指 定 重 复 次 数

要匹配某一项的特定次数重复，使用 "\<code class="special">{n,m}</code>" 这样的形式。其中 "n" 和 "m" 都是数字。
在它前面的那个项将被重复 "n" 到 "m" 次 (包含 "n" 和 "m")。例如:
<code class="example"></code>
<code class="example">        /ab\<code class="special">{3,5}</code></code>
<code class="example"></code>
匹配 "abbb"，"abbbb" 以及 "abbbbb"。
  当 "n" 省略时，被默认为零。当 "m" 省略时，被默认为无限大。当 ",m" 省略
时，就表示重复正好 "n" 次。例如:

<code class="section">        模式            匹配次数 </code>
        \<code class="special">{,4}</code>           0，1，2，3 或 4
        \<code class="special">{3,}</code>           3，4，5，等等
        \<code class="special">{0,1}</code>          0 或 1，同 \=
        \<code class="special">{0,}</code>           0 或 更多，同 *
        \<code class="special">{1,}</code>           1 或 更多，同 \+
        \<code class="special">{3}</code>            3


匹配尽可能少的字符

迄今为止，我们所讨论过的都试图匹配尽可能多的字符。若要匹配尽可能少的字符，请
用 "\<code class="special">{-n,m}</code>"。它的用法跟 "\<code class="special">{n,m}</code>" 一样，唯一的区别在于，它采用尽可能少的字符。
   例如，以下命令:
<code class="example"></code>
<code class="example">        /ab\<code class="special">{-1,3}</code></code>
<code class="example"></code>
将匹配 "abbb" 中的 "ab"。实际上，因为没理由匹配更多，所以它永远不会匹配超过
一个 b。它需要其它的来强制它超过其下限规定次数，而匹配更多的重复。
   这些同样的规则也适用于省略 "n" 和 "m" 的情形。甚至可以把两个都省略，只剩
"\<code class="special">{-}</code>"。这个项匹配其前项的重复，重复次数尽可能少，可以等于或大于零。这个项如
单独使用，则总是匹配前项的零次重复。当它跟与其它的模式合起来时，用处就大了。
例如:
<code class="example"></code>
<code class="example">        /a.\<code class="special">{-}</code>b</code>
<code class="example"></code>
这个命令匹配 "axbxb" 中的 "axb"。如果采用了下面这个模式:
<code class="example"></code>
<code class="example">        /a.*b</code>
<code class="example"></code>
由于 ".*" 匹配尽可能多的字符，整个 "axbxb" 都会被匹配。

</pre><hr><pre><b class="vimtag">*<a name="27.5">27.5</a>*</b>  多择一

在一个查找模式中，"或" 运算符是 "\|"。例如:
<code class="example"></code>
<code class="example">        /foo\|bar</code>
<code class="example"></code>
这个命令匹配了 "foo" 或 "bar"。更多的抉择可以连在后面:
<code class="example"></code>
<code class="example">        /one\|<code class="badlink">two\</code>|three</code>
<code class="example"></code>
匹配 "one"，"two" 或 "three"。
   如要匹配其多次重复，那么整个抉择结构须置于 "\(" 和 "\)" 之间:
<code class="example"></code>
<code class="example">        /\(foo\|bar\)\+</code>
<code class="example"></code>
这个命令匹配 "foo"，"foobar"，"foofoo"，"barfoobar"，等等。
   再举个例子:
<code class="example"></code>
<code class="example">        /end\(if\|<code class="badlink">while\</code>|for\)</code>
<code class="example"></code>
这个命令匹配 "endif"，"endwhile" 和 "endfor"。

一个与此相关的项是 "\&amp;"。它要求两个抉择都与同一位置的文本相符。而最终匹配的则
是最后面的那个抉择。例如:
<code class="example"></code>
<code class="example">        /forever\&amp;...</code>
<code class="example"></code>
这个命令匹配 "forever" 中的 "for" (译者: 因为第二抉择要求三个字符)。它将不匹
配，比如说 "fortuin" (译者: 不符合第一抉择)。

</pre><hr><pre><b class="vimtag">*<a name="27.6">27.6</a>*</b>  字符域

你可以用 "/a\|<code class="badlink">b\</code>|c" 来匹配 "a"，"b" 或 "c"。当你需要匹配自 "a" 至 "z" 所有的
字母时，以这样的方式表达就嫌长了。这里有个比较简短的表达方式:
<code class="example"></code>
<code class="example">        /[a-z]</code>
<code class="example"></code>
方括号结构 [] 匹配单个字符。你在括号内指定哪些字符可以匹配。你可以把一系列字
符包含在内，像这样:
<code class="example"></code>
<code class="example">        /[0123456789abcdef]</code>
<code class="example"></code>
这个命令将匹配其中的任何一个字符。你可以为一系列连续字符规定一个字符域。"0-3"
表示 "0123"。"w-z" 表示 "wxyz"。因此，上面那个命令可以缩短为:
<code class="example"></code>
<code class="example">        /[0-9a-f]</code>
<code class="example"></code>
若要匹配字符 "-" 本身，就得把它放在字符域的第一或最后的位置上。Vim 会识别下面这
些特殊字符，以便在 [] 字符域里使用它们较为方便 (它们实际上可被用于任何查找模
式的任何地方):

        \e      <code class="special">&lt;Esc&gt;</code>
        \t      <code class="special">&lt;Tab&gt;</code>
        \r      <code class="special">&lt;CR&gt;</code>
        \b      <code class="special">&lt;BS&gt;</code>

还有若干特殊场合用得上 [] 字符域，参阅 |<a href="pattern.html#%2F[]">/[]</a>| 以了解全部用法。


补 域

为了避免匹配到一个特定的字符，在字符域首位使用 "^"。这样方括号项 [] 就会匹配
任何括号内不包括的字符。例如:
<code class="example"></code>
<code class="example">        /"[^"]*"</code>

         "        双引号
          [^"]    双引号以外的任何字符
              *   尽可能多个
               "  又一个双引号

这个命令匹配 "foo" 和 "3!x"，包含双引号在内。


预 定 义 的 域

有些字符域使用得很频繁。Vim 为这些字符域提供了一些捷径。例如:
<code class="example"></code>
<code class="example">        /\a</code>
<code class="example"></code>
这个命令找寻字母字符。这相当于使用 "/[a-zA-Z]"。下面还有几个这样的字符域:

<code class="section">        项      匹配                    相当于 </code>
        \d      数码                    [0-9]
        \D      非数码                  [^0-9]
        \x      十六进制数              [0-9a-fA-F]
        \X      非十六进制数            [^0-9a-fA-F]
        \s      空白字符                [       ]     (<code class="special">&lt;Tab&gt;</code> 和 <code class="special">&lt;Space&gt;</code>)
        \S      非空白字符              [^      ]     (非 <code class="special">&lt;Tab&gt;</code> 和 <code class="special">&lt;Space&gt;</code>)
        \l      小写字母                [a-z]
        \L      非小写字母              [^a-z]
        \u      大写字母                [A-Z]
        \U      非大写字母              [^A-Z]

        <code class="note">Note:</code>
        使用这些预定义的字符域要比使用它们所表示的那个字符域快很多。
        这些项不能用于 [] 方括号内。因此 "[\d\l]" 不能用来匹配一个数字或一个
        小写字母。请换用 "\(\d\|\l\)"。

|<a href="pattern.html#%2F\s">/\s</a>| 包括一个这类域的完整的列表。

</pre><hr><pre><b class="vimtag">*<a name="27.7">27.7</a>*</b>  字符类

一个特定的字符域匹配一组固定的字符。一个字符类与字符域相似，不过有个本质的区
别: 一个字符类代表的那组字符可以重新定义而无须改动查找模式。
   例如，查找这个模式:
<code class="example"></code>
<code class="example">        /\f\+</code>
<code class="example"></code>
其中 "\f" 项表示文件名字符。因而这个命令匹配一个由可用作文件名的字符字符组成
的序列。
   哪些字符可以用来组成文件名取决于你所使用的系统。在微软视窗上，反斜线符可
以，而在 Unix 上却不行。文件名字符由 'isfname' 选项来规定。在 Unix
上，该选项的默认值为:
<code class="example"></code>
<code class="example">        :set isfname</code>
<code class="example">        isfname=@,48-57,/,.,-,_,+,,,#,$,%,~,=</code>
<code class="example"></code>
在其它系统上，其默认值各不相同。因此你可以用 "\f" 组成一个查找模式，以匹配一
个文件名。该查找模式将自动调整以适应你所使用的系统。

        <code class="note">Note:</code>
        实际上，Unix 允许在文件名里使用几乎所有的字符，包括空格字符。把这些字
        符包括在 'isfname' 里，在理论上是没错的。但那样就无法在文本中发现一个
        文件名在哪儿结束。因此选项 'isfname' 的默认值是个折衷方案。

字符类有如下这些:

<code class="section">        项      匹配                            选项 </code>
        \i      标识符字符                      'isident'
        \I      类似于 \i，但不包括数字
        \k      关键词字符                      'iskeyword'
        \K      类似于 \k，但不包括数字
        \p      可打印字符                      'isprint'
        \P      类似于 \p，但不包括数字
        \f      文件名字符                      'isfname'
        \F      类似于 \f，但不包括数字

</pre><hr><pre><b class="vimtag">*<a name="27.8">27.8</a>*</b>  匹配换行符

Vim 能找寻含有换行符的模式。你需要指定换行符在哪儿出现，因为迄今为止所有我们
曾经提到过的项，都不匹配换行符。
   用 "\n" 项可以在一个特定的位置查验一个换行符：
<code class="example"></code>
<code class="example">        /the\nword</code>
<code class="example"></code>
这个命令将在一行以 "the" 结尾，而下一行以 "word" 开头的地方找到匹配。如果还
要匹配 "the word"，那么你需要匹配一个空格或一个换行符。这可以用 "\_s" 表示:
<code class="example"></code>
<code class="example">        /the\_sword</code>
<code class="example"></code>
若要允许任意数量的空格:
<code class="example"></code>
<code class="example">        /the\_s\+word</code>
<code class="example"></code>
这个命令也匹配 "the  " 在行尾，及 "   word" 在下一行行首的情形。

"\s" 匹配空格字符，"\_s" 匹配空格字符或一个换行符。同理，"\a" 匹配一个字母字
符，而 "\_a" 匹配一个字母字符或一个换行符。其它字符类和字符域都可以通过插入一
个 "_" 来更改其范围。

很多别的项也可以在前面加 "\_" 以匹配一个换行符。例如: "\_." 匹配任意字符或一
个换行符。

        <code class="note">Note:</code>
        "\_.*" 匹配任何字符，直至文件结束。要小心，它会使查找命令执行得非常缓慢。

另一个例子是 "\_[]"，一个包含了换行符的字符域:
<code class="example"></code>
<code class="example">        /"\_[^"]*"</code>
<code class="example"></code>
这个命令找寻位于一对双引号之间，可能分隔成数行的文本。

</pre><hr><pre><b class="vimtag">*<a name="27.9">27.9</a>*</b>  举例

这儿有几个查找模式，你也许会觉得有用。本节向你演示如何综合使用前面提及的那些
用法。


寻 找 一 个 加 州 驾 驶 牌 照

有一个驾驶牌照号码为 "1MGU103"。它有一个数字，三个大写字母，然后三位数字。直
接把这个号码放入查找模式:
<code class="example"></code>
<code class="example">        /\d\u\u\u\d\d\d</code>
<code class="example"></code>
另一种方法是用一个计数器来指定其中有三个数字和三个字母:
<code class="example"></code>
<code class="example">        /\d\u\<code class="special">{3}</code>\d\<code class="special">{3}</code></code>
<code class="example"></code>
换用 [] 字符域方法:
<code class="example"></code>
<code class="example">        /[0-9][A-Z]\<code class="special">{3}</code>[0-9]\<code class="special">{3}</code></code>
<code class="example"></code>
这些方法之中你应该使用哪一种? 挑那种你记得住的。你记得住的简单方法要比你记不
住的华丽方法快得多。如果你能把它们都记住，那么避免使用最后那种，因为它要打的
字多，而且执行起来慢。


寻 找 一 个 标 识 符

在 C 程序里 (以及其它很多计算机程序) 一个标识符以字母开头，其余部分由字母和数
字组成。下划线字符也可以。这样一个标识符可以用下面的命令找到:
<code class="example"></code>
<code class="example">        /\<code class="special">&lt;\h\w*\&gt;</code></code>
<code class="example"></code>
"\<code class="special">&lt;" 和 "\&gt;</code>" 用来寻找那些完整的词。"\h" 表示 "[A-Za-z_]"，而 "\w" 则表示
 [0-9A-Za-z_]"。

        <code class="note">Note:</code>
        "\<code class="special">&lt;" 和 "\&gt;</code>" 取决于 'iskeyword' 选项。如果这个选项包括 "-" 的话，那么
         "ident-" 就不匹配了。在这种情况下，请用:
<code class="example"></code>
<code class="example">                /\w\@&lt;!\h\w*\w\@!</code>

        这个命令查验是否 "\w" 不匹配标识符之前或之后的字符。
        参见 |<a href="pattern.html#%2F\@%3C!">/\@&lt;!</a>| 和 |<a href="pattern.html#%2F\@!">/\@!</a>|。

</pre><hr><pre>
下一章: |<a href="usr_28.html#usr_28.txt">usr_28.txt</a>|  折叠

版权: 参见 |<a href="usr_01.html#manual-copyright">manual-copyright</a>|  vim:tw=78:ts=8:ft=help:norl:
</pre>
<p><i>Generated by vim2html on Fri Apr 23 15:15:06 CST 2004</i></p>
</body>
</html>
